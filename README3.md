# Оценка эффективности алгоритмов сортировки и поиска

---

## 1. Алгоритм выбора наименьшего (Selection Sort)

**Как работает:**  
Алгоритм на каждом проходе ищет наименьший элемент в неотсортированной части массива и помещает его в начало этой части, меняя местами с текущим первым элементом.

**Характеристики выполнения:**  
- Внешний цикл: `for (i = 0; i < n - 1; i++)` — определяет начало неотсортированной части.  
- Внутренний цикл: `for (j = i + 1; j < n; j++)` — ищет индекс минимального элемента в оставшейся части.  
- После завершения внутреннего цикла происходит обмен элемента `arr[i]` с найденным минимальным.

**Оценка сложности:**  
- **Худший / средний / лучший:** `O(n²)`  
- **Пояснение:** Количество операций сравнения определяется двойным циклом и составляет `n(n - 1) / 2`, что соответствует квадратичной зависимости от `n`.

---

## 2. Алгоритм сортировки пузырьком (Bubble Sort)

**Как работает:**  
Алгоритм многократно проходит по массиву, сравнивая пары соседних элементов. Если пара находится в неправильном порядке, элементы меняются местами. На каждом проходе наибольший элемент "всплывает" к концу.

**Характеристики выполнения:**  
- Внешний цикл: `for (i = 0; i < n - 1; i++)` — контролирует количество проходов.  
- Внутренний цикл: `for (j = 0; j < n - i - 1; j++)` — сравнивает соседние элементы и выполняет обмен при необходимости.  
- Может быть оптимизирован: если за проход не произошло ни одного обмена, массив уже отсортирован.

**Оценка сложности:**  
- **Худший / средний:** `O(n²)`  
- **Лучший (отсортированный массив):** `O(n)`  
- **Пояснение:** В худшем случае — `n(n - 1) / 2` сравнений и обменов. В лучшем — только `n - 1` сравнений, если массив уже упорядочен.

---

## 3. Сортировка вставками (Insertion Sort)

**Как работает:**  
Алгоритм строит отсортированную часть массива слева направо. Каждый новый элемент из неотсортированной части вставляется в правильное место среди уже отсортированных.

**Характеристики выполнения:**  
- Внешний цикл: `for (i = 1; i < n; i++)` — перебирает элементы, начиная со второго.  
- Внутренний цикл: `while (j >= 0 && arr[j] > key)` — сдвигает элементы вправо, освобождая место для вставки.  
- Переменная `key` хранит текущий элемент для вставки.

**Оценка сложности:**  
- **Худший / средний:** `O(n²)`  
- **Лучший:** `O(n)`  
- **Пояснение:** В наихудшем случае (массив отсортирован в обратном порядке) каждый элемент нужно сравнить и сдвинуть, что приводит к квадратичной сложности. При уже отсортированном массиве — линейное время.

---

## 4. Сортировка слиянием (Merge Sort)

**Как работает:**  
Алгоритм рекурсивно делит массив на две равные (или почти равные) части до тех пор, пока не останутся подмассивы из одного элемента. Затем эти подмассивы объединяются (сливаются) в отсортированные блоки.

**Характеристики выполнения:**  
- Рекурсивный вызов заменяет внешний цикл: `merge_sort(arr, left, mid)` и `merge_sort(arr, mid + 1, right)`.  
- Процедура слияния (`merge`) обрабатывает `n` элементов на каждом уровне рекурсии.  
- Требует `O(n)` дополнительной памяти для временных массивов.

**Оценка сложности:**  
- **Все случаи:** `Θ(n log n)`  
- **Пояснение:** Независимо от начального состояния массива, количество уровней `log n`, и на каждом уровне `n` элементов. Это обеспечивает стабильную логарифмическую сложность.  
- **Преимущества:** Устойчивость (не меняет относительный порядок равных элементов), предсказуемая производительность.

---

## 5. Сортировка Шелла (Shell Sort)

**Как работает:**  
Является улучшенной версией сортировки вставками. Сначала сортируются элементы, находящиеся на определённом расстоянии `gap`. Значение `gap` уменьшается по определённой схеме (например, `n/2, n/4, ..., 1`), и на последнем этапе выполняется обычная сортировка вставками.

**Характеристики выполнения:**  
- Внешний цикл уменьшает `gap`: `for (gap = n/2; gap > 0; gap /= 2)` — задаёт последовательность промежутков.  
- Внутренние циклы: внешний `for (i = gap; i < n; i++)`, внутренний `while (j >= gap && arr[j - gap] > temp)` — выполняют сортировку подмассивов с шагом `gap`.

**Оценка сложности:**  
- **Зависит от последовательности `gap`:**
  - Классическая: `O(n²)`
  - Кнута: `O(n^(3/2))`
  - Оптимальные: `O(n log n)`
- **Пояснение:** Сложность определяется тем, насколько эффективно уменьшение `gap` устраняет инверсии в массиве.

---

## 6. Быстрая сортировка (Quick Sort)

**Как работает:**  
Алгоритм выбирает опорный элемент (pivot). Затем массив делится на две части: элементы, меньшие опоры, и элементы, большие или равные ей. Затем рекурсивно сортируются обе части.

**Характеристики выполнения:**  
- Рекурсивные вызовы заменяют внешний цикл: `quick_sort(arr, low, pi - 1)` и `quick_sort(arr, pi + 1, high)`.  
- Процедура `partition` за один проход (`for` или `while`) переставляет элементы относительно опоры.  
- Глубина рекурсии варьируется от `log n` до `n`, в зависимости от баланса разбиения.

**Оценка сложности:**  
- **Средний случай:** `O(n log n)`  
- **Худший случай (например, отсортированный массив, неудачный выбор опоры):** `O(n²)`  
- **Пояснение:** При неудачном выборе опорного элемента разбиение может быть вырожденным (одна часть пуста), что приведёт к линейной глубине рекурсии и, как следствие, к квадратичной сложности.

---

## 7. Пирамидальная сортировка (Heapsort)

**Как работает:**  
Сначала из массива строится двоичная куча (max-heap). Затем максимальный элемент (корень кучи) извлекается и помещается в конец массива. Куча перестраивается, и процесс повторяется.

**Характеристики выполнения:**  
- Внешний цикл: `for (i = n - 1; i > 0; i--)` — извлекает корень и перемещает его в конец.  
- Внутренний процесс: `heapify(arr, i, 0)` — восстанавливает свойства кучи после извлечения.  
- Построение кучи выполняется один раз в начале за `O(n)`.

**Оценка сложности:**  
- **Все случаи:** `Θ(n log n)`  
- **Пояснение:** Построение кучи линейно, а `n` извлечений требуют `log n` операций на каждом.  
- **Преимущество:** Работает in-place (без дополнительной памяти `O(n)` как у слияния).  
- **Недостаток:** Неустойчивая (может изменить порядок равных элементов).

---

## 8. Линейный поиск (Linear Search)

**Как работает:**  
Алгоритм просматривает элементы массива один за другим, начиная с первого, и сравнивает каждый с искомым значением до тех пор, пока не найдёт совпадение или не дойдёт до конца.

**Характеристики выполнения:**  
- Единственный цикл: `for (i = 0; i < n; i++)` — последовательно проверяет каждый элемент.  
- При нахождении совпадения возвращает индекс и завершает работу.  
- Не требует сортировки.

**Оценка сложности:**  
- **Все случаи:** `O(n)`  
- **Пояснение:** В худшем случае (элемент в конце или отсутствует) нужно проверить `n` элементов.

---

## 9. Двоичный (бинарный) поиск (Binary Search)

**Как работает:**  
Применяется **только** к **отсортированным** массивам. На каждом шаге текущая область поиска делится пополам. Искомое значение сравнивается с элементом в середине. В зависимости от результата, поиск продолжается в левой или правой половине.

**Характеристики выполнения:**  
- Цикл: `while (left <= right)` — управляет границами поиска.  
- На каждой итерации вычисляется `mid = (left + right) / 2` и сравнивается `arr[mid]` с целью.  
- Границы обновляются: `left = mid + 1` или `right = mid - 1`.

**Оценка сложности:**  
- **Худший / средний:** `O(log n)`  
- **Лучший (элемент сразу в середине):** `O(1)`  
- **Пояснение:** Размер области поиска уменьшается вдвое на каждом шаге, что приводит к логарифмической зависимости.

---

## 10. Интерполяционный поиск (Interpolation Search)

**Как работает:**  
Улучшенная версия двоичного поиска, эффективная для **отсортированных** массивов с **равномерным** распределением значений. Вместо деления пополам, позиция для проверки вычисляется с помощью **линейной интерполяции**, как будто значения расположены равномерно.

**Характеристики выполнения:**  
- Цикл: `while (low <= high && target >= arr[low] && target <= arr[high])` — продолжает поиск, пока значение находится в диапазоне.  
- Позиция вычисляется по формуле:  
  `pos = low + ((target - arr[low]) * (high - low)) // (arr[high] - arr[low])`  
- Обновление границ аналогично бинарному поиску, но с учётом вычисленной позиции.

**Оценка сложности:**  
- **При равномерном распределении:** `O(log log n)`  
- **В худшем случае (например, экспоненциальное распределение):** `O(n)`  
- **Лучший случай:** `O(1)`

---

## 11. Поиск по Фибоначчи (Fibonacci Search)

**Как работает:**  
Аналог бинарного поиска, но деление массива происходит не пополам, а в пропорциях, определяемых **последовательностью чисел Фибоначчи**. Это позволяет использовать только сложение и вычитание, а не деление.

**Характеристики выполнения:**  
- Цикл: `while (fib_m2 < n)` — находит наименьшее число Фибоначчи ≥ `n`.  
- Основной цикл: `while (offset < n)` — сравнивает `arr[offset + fib_m2]` с целью.  
- Обновление индексов использует предыдущие числа Фибоначчи (`fib_m`, `fib_m1`, `fib_m2`).

**Оценка сложности:**  
- **Все случаи:** `O(log n)`  
- **Пояснение:** Количество итераций пропорционально логарифму от индекса числа Фибоначчи, превышающего `n`.

